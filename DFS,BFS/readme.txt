풀이방법:
1. 입력값들을 받는다.
2. 간선이 어떻게 구성되는지에 대한 ArrayList와 방문했는지의 유무를 파악하는 visited배열을 만든다.
3. 입력값대로 ArrayList에 추가해준다. 이때 순방향,역방향 모두 연결한다.
4. 문제에서 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문한다 하였음으로 Collections.sort를 통해 ArrayList를 한전 정렬한다.
5. dfs의 경우 시작위치에서 부터 간선이 존재하는 정점을 발견할 경우, 재귀를 통해 해당 정점으로 부터 더이상 간선이 나오지 않을 때까지 반복한다.
6. dfs를 마친이후, fill을 통해서 visited 배열 값 상태를 초기화 시킨다.
7. bfs의 경우 Queue를 이용하여 시작점으로 부터 방문되는 정점들을 모두 저장한다음, Queue가 비워질 때까지 정점값들을 하나씩 꺼내면서 또 간선을 가진 정점이 나올경우 다시 Queue에 넣어주고 더 이상 간선이 나오지 않을 때까지 이러한 과정을 반복한다.


문제링크: https://www.acmicpc.net/problem/1260